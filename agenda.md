---
layout: default
---

# Lecture plan

## Introduction (Monday 14/1)

* Historical overview
* Imperative and decalarative programming
* Complexity
* The perils of mutable state
* Static and dynamic typing
* Abstraction
* Data representation
* Composition

## Functions

* Relations vs. functions
* Introduction to Lambda calculus
* Binding and environments
* Pure functions: Expressions and statements
* Referential transparency
* Composition
* Higher-order functions
* Currying and partial application
* Recursion and tail call optimization

## Types and type systems

* Introduction to types
* Type systems and type checking
* Type inference
* The Curry-Howard isomorphism
  * Existence as proof
* Algebraic data types
* OOP features

## Introduction to F\# on .NET Core

* Order of declarations and files
* Mutual recursion: types, functions and modules
* Pattern matching
* Active patterns
* Mutable variables

## Patterns and abstraction

* Monoids
* Functors
* Applicative functors
* Monads

## Desing patterns

* Lenses
* Dependency injection

## Generic programming in F\#

* Types, classes and members
* Interfaces
* Constraints

## Designing with types

* Stating intent
* Domain modeling
* Algebraic types as conjunction and disjunction
* Making invalid state unrepresentable

## Domain Specific Languages

* Combinators
* HTML combinators

## Reactive programming

* Fable React
* Fable Elmish


